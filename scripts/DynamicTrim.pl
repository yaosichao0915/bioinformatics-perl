#!/usr/bin/env perl

# Program: DynamicTrim v.1.1
# Trims each sequence of a FASTQ file individually to the longest contiguous segment 
# in which the quality score of each base is superior to an input quality cutoff
# Daniel Peterson and Murray Cox
# Massey University Palmerston North, New Zealand
# Email contact <m.p.cox@massey.ac.nz>
# September 2010

# Released under GNU General Public License version 3

use strict;
use warnings;
use Getopt::Long;

my $usage = "
$0 input_files [-p|pcutoff 0.05] [-h|phrdcutoff 13] [-o|oldpipeline] [-roche]\n
-p|pcutoff	probability value (between 0 and 1) at which base-calling error is considered too high *or*
-h|phrdcutoff   Phred score (between 0 and 40) at which base-calling error is considered too high
-o|oldpipeline  select this option if input FASTQ files were generated by Solexa pipeline v.1.2 or earlier
-454            set flag if trimming roche data
\n";

# if not input files provided, quit and print usage information
if( !$ARGV[0] ){ die "$usage"; }

# create cutoff variables
my $prob_cutoff;
my $phrd_cutoff;
my $ascii_cutoff;

my $old_pipeline   = 0;
my $input_pipeline = 0;

my $roche;

# Get user input
GetOptions(
	"p|pcutoff=f"	 => \$prob_cutoff,
	"h|phrdcutoff=f" => \$phrd_cutoff,
	"o|oldpipeline"  => \$input_pipeline,
	"454"            => \$roche
);

my @files = @ARGV;

# check for presence of at least one input file
if( !$files[0] ){ die "$usage"; }

# don't run old_pipeline with roche
if( $roche && $input_pipeline ){
	die "error: old pipeline can not be used with roche data\n";
}

# check for correct cutoff input
if( !defined( $prob_cutoff ) && !defined( $phrd_cutoff ) ){
	$prob_cutoff = 0.05;
	print STDOUT "using default quality cutoff of p = $prob_cutoff (change with -p or -h flag)\n";

}elsif( defined( $prob_cutoff ) && defined( $phrd_cutoff ) ){
	die "error: please enter either a probability or a Phred quality cutoff value, not both";

}elsif( defined( $prob_cutoff ) && ( $prob_cutoff < 0 || $prob_cutoff > 1 ) ){
	die "error: p quality cutoff must be between 0 and 1";

}elsif( defined( $phrd_cutoff ) && $phrd_cutoff < 0 ){
	die "error: Phred quality cutoff must be greater than or equal to 0";
}

# temp
#die &print_lookup_table;

# convert input probability or Phred quality cutoff values to the equivalent ascii character
if( defined( $phrd_cutoff ) ){
	$ascii_cutoff = &Q_to_q( $phrd_cutoff );

}else{
	$ascii_cutoff = &Q_to_q( &p_to_Q( $prob_cutoff ) );
}

# set input pipeline type
$old_pipeline = $input_pipeline;

foreach my $input_file ( @files ){

	# open input file for reading
        open( INPUT, "<$input_file" ) or die "error: failure opening $input_file for reading: $!\n";

        # just get filename, not full path (as returned by @ARGV)
        my @filepath = split( /\//, $input_file );
        my $filename = $filepath[$#filepath];

	# create and open output file
	my $output_file = $filename . ".trimmed";

	if( -e $output_file ){
		die "error: output file $output_file already exists: $!\n";
	}    
	open( OUTPUT, ">$output_file" )
                or die "error: failure opening $output_file for writing: $!\n";

	my @segment_hist;
	my $segment_sum   = 0;
	my $segment_count = 0;

	my $seq_count = 0;

	# step through input
	while( <INPUT> ){

		# first line of each group has the sequence ID
		my $ID1 = $_;

		# check that sequence ID has FASTQ '@' indicator
		if( substr( $ID1, 0 , 1) ne "@" ){
			die "error: input file not in correct FASTQ format at seq ID $ID1\n";
		}

		# second line of the group has the sequence itself
		chomp( my $seq_string = <INPUT> );

		# store the sequence as an array
		my @seq_array = split( //, $seq_string );

		# third line of the group has the sequence ID again
		my $ID2 = <INPUT>;

		# check that third line has FASTQ '+' indicator
                if( substr( $ID2, 0 , 1) ne "+" ){
                        die "error: input file not in correct FASTQ format at qual ID $ID2\n";
		}								                

		# fourth line of the group has the quality scores
		chomp( my $quality_string = <INPUT> );

		# store the quality scores in an array
		my @quality_array = split( //, $quality_string );

		# store the original length of the read
		my $original_length  = scalar( @quality_array );

		# initialize variables used in segment analysis
		my $cutoff_hit       =  0;
		my $best_start_index =  0;
		my $best_end_index   = -1;
		my $best_length      =  0;
		my $current_start    =  0;

		# loop through each position in the read
		for( my $i = 0; $i < $original_length; $i++ ){

			# if the quality score at this position is worse than the cutoff
			if( $quality_array[$i] le $ascii_cutoff ){

				$cutoff_hit = 1;

				# determine length of good segment that just ended
				my $current_segment_length = $i - $current_start;

				# if this segment is the longest so far
				if( $current_segment_length > $best_length ){

					# store this segment as current best
					$best_length      = $current_segment_length;
					$best_start_index = $current_start;
					$best_end_index   = $i - 1;
				}

				# reset current start
				$current_start = $i + 1;
			}
		}

		# if quality cutoff is never exceeded, set the marker for the end of the good segment
		# to the end of the read
		if( !$cutoff_hit ){
			$best_end_index = scalar( @quality_array ) - 1;
			$best_length = scalar( @quality_array );
		}

		if( !defined($segment_hist[ $best_length ] ) ){
			$segment_hist[ $best_length ] = 0;
		}

		# increment variables that store segment statistics
		$segment_hist[ $best_length ]++;
		$segment_sum += $best_length;
		$segment_count++;
		
		# remove all bases not part of the best segment from the beginning of the sequence and quality arrays
		for( my $i = 0; $i < $best_start_index; $i++ ){

			shift( @quality_array );
			shift( @seq_array );
		}
		
		# remove all bases not part of the best segment from the end of the sequence and quality arrays
		for( my $i = $original_length - 1; $i > $best_end_index; $i-- ){
			
			pop( @quality_array );
			pop( @seq_array );
		}

		# if the "best" segment has a length of 0, set sequence to a single 'N' and quality score to a single 'B'
		if( scalar( @seq_array ) == 0 ){

			$seq_array[0]     = "N";
			$quality_array[0] = "B";
		}
		
		# print ID lines, trimmed sequence, and trimmed quality scores to output file
		print OUTPUT $ID1, @seq_array, "\n", $ID2, @quality_array, "\n";
	}

	# calculate mean segment length
	my $segment_mean = sprintf( "%.1f", $segment_sum / $segment_count );

	# set index at halfway through segment counts 
	my $halfway_index = $segment_count / 2;

	# set variables needed to find median segment length
	my $current_sum   = 0;
	my $current_index = 0;
	my $median_index1;
	my $median_index2;
	
	# while median_index1 and median_index2 are not defined
	while( !defined( $median_index1 ) || !defined( $median_index2 ) ){

		# add segment count to current sum for each segment length from array
		if( defined( $segment_hist[ $current_index ] ) ){
		
			$current_sum += $segment_hist[ $current_index ];
		}

		# if current sum of segment counts has surpassed halfway index
		if( $current_sum > $halfway_index ){
		
			# if median_index1 has not been defined, store current segment length
			if( !defined( $median_index1 ) ){
				$median_index1 = $current_index;
			}

			# if median_index2 has not been defined, store current segment length
			if( !defined( $median_index2 ) ){
				$median_index2 = $current_index;
			}
		
		# else if current sum of segment counts is exactly equal to the halfway index
		}elsif( $current_sum == $halfway_index	&& !defined( $median_index1 ) ){

			# store current segment length as median_index1
			$median_index1 = $current_index;
		}

		# loop through all possible segment lengths
		$current_index++;
	}
	
	$current_index--;

	my $segment_median;

	# if number of segments is odd, store index2 as median segment length
	if( $segment_count % 2 == 1){
		$segment_median = $median_index1;

	# if number of segments is even, store average of index1 and index2 as median segment length
	}else{
		$segment_median = sprintf( "%.0f", ( ( $median_index1 + $median_index2 ) / 2 ) );
	}

	# print mean and median segment length
	print STDOUT "$output_file: mean segment length = $segment_mean, median segment length = $segment_median\n";

	# close input and output files
	close INPUT or die "error: cannot close $input_file: $!";

	close OUTPUT or die "error: cannot close $output_file; $!";
}
			
# terminate
exit 0 or die "error: $0 ended abnormally: $!\n";

# ----------------------------------------------------

# Change ASCII character to Phred/Solexa quality score
sub q_to_Q($){

        my $q = shift;
        if( $roche ){
        	return ord($q) - 33;
        }else{
        	return ord($q) - 64;
        }
}

# Change Phred/Solexa quality score to ASCII character
sub Q_to_q($){

        my $Q = shift;
        if( $roche ){
        	return chr($Q + 33);
        }else{
        	return chr($Q + 64);
        }
}

# Change Phred/Solexa quality score to probability
sub Q_to_p($){

	my $Q = shift;

	if( $old_pipeline == 1 ){
		return (10**(-$Q/10)) / ((10**(-$Q/10))+1);
	}else{
		return (10**(-$Q/10));
	}
}

# Change probability to Phred/Solexa quality score
sub p_to_Q($){

	my $p = shift;

        if( $old_pipeline == 1 ){
		return -10 * &log10($p/(1-$p));
        }else{
		return -10 * &log10($p);
        }
}

# log10 function
sub log10($){

	my $number = shift;
	return log($number)/log(10);
}

# print summary of Q, q and p values
sub print_lookup_table(){
	
	print STDOUT "Char\tQPhred\tProb\n";
	for( my $i = -5; $i <= 40; $i++ ){
		
		my $q = &Q_to_q($i);
		my $p = &Q_to_p($i);
		
		print STDOUT $q, "\t";
		print STDOUT $i, "\t";
		print STDOUT sprintf("%.8f", $p), "\n";
	}
}
